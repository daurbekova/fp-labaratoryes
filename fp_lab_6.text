6-зертхана: Функционалды реактивті бағдарламалау (FRP) 
 
Мақсат: 
Python контекстінде функционалдық реактивті бағдарламалау (FRP) принциптерін үйреніңіз және қолданыңыз. Жұмыстың мақсаты - деректер ағындарын, реактивті айнымалыларды және асинхронды оқиғаларды өңдеуді қоса алғанда, FRP негізгі тұжырымдамаларын түсіну және жауап беретін және модульдік қосымшаларды жасау үшін осы тұжырымдамаларды пайдалану дағдыларын дамыту. 
 
Тапсырма:
13.	FRP жүктеп алу барысының көрсеткіші 
-	Файлды жүктеу процесі кезінде реактивті түрде жаңартылатын орындалу көрсеткішін жасаңыз. 
from rx import interval, operators as op
from time import sleep
def simulate_download():
    total_size = 1000  # Общий размер файла
    downloaded = 0  # Количество загруженных байтов
    while downloaded < total_size:
        downloaded += 100
        yield downloaded / total_size
        sleep(1)
progress_stream = interval(1).pipe(op.map(lambda _: next(simulate_download())), op.take_while(lambda progress: progress < 1))
progress_stream.subscribe(lambda progress: print(f"Progress: {progress * 100:.1f}%"))
while True:
    pass

import sys
import requests
def download(url, fil_ename):
    with open(fil_ename, 'wb') as f:
        res = requests.get(url, ag_yn=True)
        jami = res.headers.get('content-length')

        if jami is None:
            f.write(res.content)
        else:
            zhuktelgen = 0
            jami = int(jami)
            for data in res.iter_content(chunk_size=max(int(jami / 1000), 1024 * 1024)):
                zhuktelgen += len(data)
                f.write(data)
                done = int(50*zhuktelgen / jami)
                sys.stdout.write('\r[{}{}]'.format('█' * done, '.' * (50 - done)))
                sys.stdout.flush()
    sys.stdout.write('\n')

Python файлын жүктеп алуға орындалу жолағын қосу үшін кітапхананы пайдалана аласыз tqdm. Бұл қадамдық нұсқаулық процесті үш негізгі бөлікке бөледі: HTTP сұрауын жасау, деректерді тасымалдауды өлшеу және консольде орындалу барысын көрсету.
1-қадам: HTTP сұрауын дайындау HTTP сұрауын бастау және орындалу жолағы жоқ файлды жүктеп алу үшін кітапхананы пайдалануға болады requests. Мысалы:
import requests

url = 'https://www.example.com/file.txt'
with requests.get(url) as r:
   with open('download.txt', 'wb') as file:
   file.write(r.content)
Бұл негізгі код файлды жүктеп алып, оны жергілікті түрде сақтайды. Дегенмен, оған прогресс жолағы жоқ.
2 және 3-қадамдар: Деректерді тасымалдауды өлшеу және көрсету Орындалу жолағын енгізу үшін кітапхананы tqdmкітапханамен бірге пайдалануға болады requests. Біріншіден, қолмен жүзеге асыру:
import time
import requests

url = 'https://www.example.com/file.txt'
with requests.get(url, stream = True) as r:
   with open('download.txt', 'wb') as file:
   total_size = int(r.headers.get('Content-Length'))
chunk_size = 1

for i, chunk in enumerate(r.iter_content(chunk_size = chunk_size)):
   c = i * chunk_size / total_size * 100
print(f "\r{round(c, 4)}%", end = '')
time.sleep(0.1)
Бұл код консольде жүктеу пайызын көрсете отырып, файл мазмұны бойынша қайталанады. Дегенмен, оның кейбір кемшіліктері бар, соның ішінде әрбір бөлік үшін кідіріс.
tqdm Implementation Қолданылатын жеңілдетілген тәсіл tqdm:
import os
import requests
import shutil
from tqdm.auto
import tqdm

url = 'https://www.example.com/file.txt'
with requests.get(url, stream = True) as r:
   total_length = int(r.headers.get("Content-Length"))
with tqdm.wrapattr(r.raw, "read", total = total_length, desc = "") as raw:
   with open(f "{os.path.basename(r.url)}", 'wb') as output:
   shutil.copyfileobj(raw, output)
Бұл кодта tqdmжалпы орындалу барысы, динамикалық түрде жаңартылған орындалу жолағы, жүктеп алынған жалпы байттар, өткен уақыт және деректерді тасымалдау жылдамдығы сияқты мәліметтерді қоса алғанда, орындалу жолағын көрсетудің қысқаша әдісі берілген.
Модульдің tqdmжеңіл ізі бар және coloramaдисплей мәтінінің түсін реттеуге мүмкіндік беретін теңшеу үшін кітапхананы қажет етеді. Бұл тәсіл Python-да файлдарды жүктеп алу кезінде пайдаланушы тәжірибесін айтарлықтай жақсартады.
Қажетті кітапханаларды орнату үшін келесі әрекеттерді орындаңыз:
pip install tqdm colorama
github.comcolorama кітапханасын және Python github.com кітапханасын зерттеңіз .tqdm
Мұндағы жалғыз шынайы сиқыр консольге ағынмен жіберу үшін sys.stdout.write әдісін, .1 миллисекундқа үзіліс жасау үшін time.sleep әдісін, содан кейін курсорды бірінші таңбаға қайта жылжыту үшін sys.stdout.flush әдісін пайдалану болып табылады. . Бұл ұқыпсыз, тіпті оның қазіргі көзқарасында да айтарлықтай жақсартылуы мүмкін және әрбір бөлік өлшемі үшін .1 мс кідіріс қосады — бұл жоғарыдағы мысалдағы бір байт. Неғұрлым жеңілдетілген тәсілді қарастырайық. Бұл жерде мәтінмәндік басқарушыларды пайдалану өз қалауынша, сұрау.get қоңырауы онсыз орындалады — оны әдет күші деп атаңыз.

14.	Реактивті пішінді басқару 
-	FRP көмегімен нақты уақыттағы деректерді тексеру арқылы пішінді әзірлеу. 15. FRP бойынша «Жылан» ойыны 
-	«Жылан» ойынының реактивті нұсқасын жасаңыз, онда жыланның қозғалысы және жаңа элементтердің пайда болуы оқиғалар ағымымен басқарылады. 
 
Бағалау критерийлері: 
-	Жеке есепті шешу үшін код жазу: 1 ұпай 
-	Қорғау кезінде жазылған кодты түсіндіру және түсіну: 2 ұпай 
-	Мұғалім таңдаған теориялық сұрақтардың біріне жауап: 1 ұпай 
 
Дайындық сұрақтары: 
1. Функционалды реактивті бағдарламалау дегеніміз не және оны қандай жағдайларда қолдану керек? 
   - Мақсаты: FRP анықтамасын және оны қолдану сценарийлерін түсіну. 
2. FRP негізгі ұғымдары қандай? 
   - Мақсаты: Деректер ағындары және реактивті күй сияқты FRP құрылыс блоктары туралы білімді бағалау. 
3. FRP оқиғаны өңдеудің дәстүрлі тәсілінен несімен ерекшеленеді? 
   - Мақсат: FRP және басқа оқиғаларды өңдеу үлгілерінің арасындағы айырмашылықтарды түсіну. 
4. FRP бағдарламалық жасақтаманы әзірлеушілерге қандай артықшылықтар береді? 
   - Мақсаты: Күйді басқаруды жеңілдету және код модульділігі сияқты артықшылықтарды түсінуді тексеру. 
5. FRP енгізу үшін қандай Python кітапханаларын пайдаландыңыз және неліктен? 
   - Мақсаты: Оқушылардың қол жетімді құралдар туралы білімін және мәселені шешу үшін таңдауын бағалау. 
6. FRP-де деректер ағынын жүзеге асыру жолын түсіндіре аласыз ба? 
   - Мақсаты: Студенттің FRP-де деректер ағындарын құру және басқару механизмін түсінуін тексеру. 
7. FRP асинхронды операцияларды қалай өңдейді? 
- Мақсаты: Оқушылар FRP асинхронды кодты өңдеуге және жанама әсерлерді өңдеуге қалай мүмкіндік беретінін түсінеді. 
8.	FRP пайдалануда қандай қиындықтар болуы мүмкін және оларды қалай жеңуге болады? 
   Мақсаты: Оқушылардың мүмкін болатын қиындықтар мен оларды шешу жолдары туралы хабардарлығын анықтау. 
9.	Қолданбаңызда немесе ойыныңызда реактивті әрекетті қалай тексердіңіз?    - Мақсаты: Реактивті жүйелерді сынау әдістерін түсіну. 
10.	FRP-де өнімділік мәселелері қандай болуы мүмкін және оларды қалай оңтайландыруға болады? 
-	Мақсаты: Реактивті қолданбалардың өнімділігі және оңтайландыру әдістері туралы білімдерін бағалау. 
11.	FRP-де жалқау бағалау қолданылатын мысал келтіре аласыз ба? 
-	Мақсаты: Жалқау бағалауды түсінуді және оны FRP контекстінде қолдануды тексеру. 
12.	FRP қолданбадағы күйді басқаруға қалай әсер етеді? 
-	Мақсаты: FRP жағдайды басқаруға әсерін және оның нақты уақыттағы өзгерістерін түсіну. 
13.	FRP-мен жұмыс істегенде қандай дизайн үлгілері пайдалы болуы мүмкін? 
-	Мақсаты: FRP-ны тиімді толықтыратын дизайн үлгілері туралы білімді бағалау. 
14.	Қолданыстағы қолданбаларға FRP қалай біріктіруге болады? 
-	Мақсат: кодты толығымен қайта жазбай-ақ, ағымдағы жобаларға FRP біріктіру тәсілдерін түсіну. 
15.	FRP қолданбаңыздағы деректер ағындарына жазылудан бас тартуды қалай басқарасыз? 
-	Мақсаты: Реактивті қолданбаларда жазылудың өмірлік циклін дұрыс басқару туралы білімдерін тексеру. 
 
 
Пример для решения  
Задача: Реактивное Отслеживание и Отображение Данных Температуры 
 
Представьте, что у вас есть поток данных о температуре, поступающих из различных источников (например, датчиков температуры). Задача состоит в том, чтобы реализовать простую реактивную систему на Python, которая отслеживает эти данные в реальном времени и обновляет среднюю температуру при каждом новом поступлении данных. 
 
Цель задачи: 
Создать реактивную систему, которая подписывается на поток данных о температуре, вычисляет и отображает обновленное среднее значение температуры при каждом изменении в потоке. 
 
Решение: 
 
Для этой задачи мы можем использовать библиотеку RxPy (Reactive Extensions for Python), которая предоставляет инструменты для реактивного программирования. 
 
Сначала установите RxPy, если она еще не установлена: 
 
pip install rx 
 
Теперь давайте создадим решение: 
 
import rx 
from rx import operators as ops 
 
# Эмуляция потока данных о температуре 
temperature_data = rx.of(20, 21, 22, 21, 20, 19, 20, 21, 22, 23) 
 
# Реактивное вычисление средней температуры average_temperature = temperature_data.pipe( 
    ops.scan(lambda acc, temp: (acc[0] + temp, acc[1] + 1), (0, 0)),     ops.map(lambda acc: acc[0] / acc[1]) 
)  
# Подписка и вывод результата average_temperature.subscribe(     lambda avg_temp: print(f"Средняя температура: {avg_temp:.2f}°C") 
)  
#### Объяснение: 
 
-	Мы создаём поток `temperature_data`, который эмулирует поступление данных о температуре. 
-	`pipe` используется для создания цепочки операторов, обрабатывающих поток данных. 
-	С помощью `ops.scan` мы накапливаем сумму температур и количество измерений для дальнейшего вычисления среднего значения. 
-	`ops.map` преобразует накопленные данные в среднее значение температуры. 
-	`subscribe` используется для отслеживания результатов и вывода обновленного среднего значения температуры. 
 
Это решение демонстрирует основные принципы FRP: реактивное отслеживание изменений в данных и декларативное определение логики обработки данных. Оно показывает, как FRP позволяет легко реагировать на изменяющиеся данные и создавать отзывчивые приложения. 
